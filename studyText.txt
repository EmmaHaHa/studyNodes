StudyText

2018/03/07
1，js中forEach
forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。

2，js值类型
string，number，boolean，null，undefined，object，symbol（ES6新增类型）。
Typeof 数据：返回数据类型6个，null类型也返回object。无返回值function类型会返回function。

3，知识点：类型转换。

2018/03/08
1，js中的this:指向调用他的对象
function foo(){console.log()this.bar;}
var bar=‘global’;//定义全局变量，属于window
var obj1={//定义对象里面包含foo方法
    bar:’obj1’,
    foo:foo
}
var obj2={bar:’obj2’}//定义对象不包含foo方法

foo()//global 函数直接调用this指向window
obj1.foo();//obj1 对象调用指向调用的对象
foo.call(obj2);//obj2 改变this指向，apply与之类似
new foo();//undefined 重新new的对象中不包含bar变量，this指向new的对象

2，js中eval（）；//接受字符串作为参数传入。参数必需。要计算的字符串，其中含有要计算的 JavaScript 表达式或要执行的语句。

3，js中with 语句用于设置代码在特定对象中的作用域。


4，函数声明与函数表达式的区分：如果function是语句中第一个出现的就为函数声明，否则为函数表达式。
5，函数表达式是可以匿名的，但是函数声明不能省略名称。
6，var a=2;
     (function IIFE(global){
	var a=3;
	console.log(a);//3
	console.log(global.a);//2
     })(window)
函数立即调用，且传入参数为window，然后重命名为global进行调用。这是一种函数表达式的调用。
7，js中变量先声明，后赋值。存在声明提升。
函数声明会被提升，但是函数表达式不会提升。即函数表达式不可再声明前些调用，函数声明可以。
函数声明和变量声明都会被提升，但是函数声明hi被先提升，然后是变量。
2018/03/09
1,闭包
		for (var i = 0; i <= 5; i++) {
            (function() {
                setTimeout(() => {
                    console.log("第一个" + i);
                }, i * 1000);
            })()//输出6个6
        }
        for (var i = 0; i <= 5; i++) {
            setTimeout(() => {
                console.log("第二个" + i);
            }, i * 1000);//输出6个6
        }
        for (var i = 0; i <= 5; i++) {
            (function() {
                var j = i;
                setTimeout(() => {
                    console.log("第三个" + j);
                }, j * 1000);
            })()//输出0-5
        }

		for (var i = 0; i <= 5; i++) {
            let j = i;//var j=I—输出6个5
            setTimeout(function() {
                console.log("第四个" + j);
            }, j * 1000)//0-5
        }        for (var i = 0; i <= 5; i++) {
            (function(j) {
                setTimeout(function() {
                    console.log(j);
                }, j * 1000)
            })(i)//0-5
        }

2，this是运行时绑定，不是编写时帮定。他依赖函数上下文关系。this绑定和函数声明
的位置无关，反而和函数被调用有关。
var bar=new foo（）；//this只想new的对象
全局的话指向global，apply、call、bind的话指向绑定的调用对象。
2018/03/12
1，对象来自于两种形式：字面形式、构造形式。
内建对象：String、Number、Boolean、Object、Function、Array、Date、RegExp、Error。
2，对象访问方式：属性访问、键访问。对象中属性名总是字符串，如果使用字符串以外的类型会自动转换为字符串。
var myObject={a:2};
myObject.a;//2
myObject[“a”];//2
3，通过键动态访问，动态创建字符串键。
var idx=“a”；
var hello=“hello”;
var myObject={a:2}；
myObject[“strMsg”]=“sdjfhjfhdj”;  计算性属性名
myObject[hello+“strMsg”]=“21345”;
console.log(myObject[index]);//2
console.log(myObject[“strMsg”]);//sdjfhjfhdj
console.log(myObject[“hellostrMsg”]);//21345  计算性属性名

4,JSON.stringify();//对象转换为json对象
 JSON.parse();//json数据转换为对象

2018/03/13
1，js中，变量没有类型，值才有类型。
2，typeof操作符总是返回字符串：”number”,”string”,”object”,”function”,”boolean”,”symbol”,”undefined”.
3，js数组array是被数字索引的，可以在它们上面添加键属性添加值，但是不会记入数组长度，数组可访问。
4，var a=[]; a[“13”]=42;//a.length:14
5，indexOf();//得出索引的位置
6，concat();//数组和string拼接。原有数组和string不变。
7，string上没有一个方法是可以原地修改它的内容的，而是创建并返回一个新的string。//string不可变性
8，split()//字符串转换为数组      join()将数组转换为字符串
9，null是关键字不是标识符，undefined是标识符不是关键字。
10，js中基本数据类型是通过值拷贝(null,undefined,string,number,boolean,symbol):var a=2;var b=a;b++;b—3 a--2。
     复合值object和function总是在赋值或传递时创建一个引用的拷贝。var c=[1,2,3];var d=c;d.push(4);c==d==[1,2,3,4]。
11，function(x){
	x.push(4);
	x;//[1,2,3,4]
	
	x=[4,5,6];//重新赋值，对原来的引用a无影响
	x.push(7);//x:[4,5,6,7]
     }
     var a=[1,2,3];
     foo(a); a的值依然为[1,2,3,4]而不是[4,5,6,7]

要改变a，不能新建array而要修改现存的array值
function foo(x){
  x.push(4);//x,a—[1,2,3,4]
  x.length=0;
  x.push(4,5,6,7);//x,a—[4,5,6,7]
}
  var a=[1,2,3];
  foo(a); a的值依然为[4,5,6,7]而不是[1,2,3,4]
12，toString()返回对象类型—[object type]
Object.prototype.toString.call([1,2,3]);//“[object Array]”
13，String.prototype.XYZ会被缩写为String#XYZ。
String#indexOf(…)//在一个字符串中找出子字符串的位置
String#charAt(…)//访问一个字符串中某个位置的字符
String#substr(…)/substring(…)/slice(…)//将字符串的一部分抽取为一个新字符串
String#toUpperCase()/toLowerCase()//创建一个转换大小写的新字符串
String#trim//创建一个截去开头或结尾空格的新字符串。


2018/03/23
1，html hash
2，scrollIntoView
3，document.documentElement.scrollTop || document.body.scrollTop 页面滚动条离顶部距离
4，sticky footer

2018/03/29
1，table-layout:fixed;以及table布局；
学习到7-10

2018/06/11
1.检测类型：typeof ‘检测的数据’--（string.number.boolean.undefined.object(包括null)）;
2,‘检测的对象’ instanceof Object/Array/RegExp 返回true或false，基本数据类型检测永远返回false--因为基本数据类型不是对象.--es3加属性

2018/07/19
1,Array.isArray(value)--es5新增加属性

2，所有对象都具有toLocalString()/toString()/valueOf()方法。
value.toString()--操作数组返回数组中值为以逗号分隔的字符串
value.valueOf()--操作数组返回的还是数组
join()--拼接数组为字符串 括号内不传值或者unedefined，默认为逗号拼接
toLocalString()/toString()/valueOf()/join()--数组中某项为null、undefined，返回结果中用空字符串表示。

3，数组的栈方法--push、pop  --栈后进先出
A,push向数组末尾添加元素；返回新的数组
B,pop移除数组最后一项，返回移除项的值。

4，数组队列方法--队列先进先出 unshift、shift
shift()返回移除项值，移除的为数组第一项。
unshift()在数组前面添加元素。

5，数组重排序方法
A.reverse()--由大到小排序，反转数组排序
B,SORT()--默认情况下升序 [0,1,10,5,15]--返回[0,1,10,15,5] 以toString比较后返回值
手动添加比较函数完善
Var item=[0,1,10,5,15]
funtion compare(val1,val2){
	return val2-val1;
}
item.sort(compare);--ok [0,1,5,10,15]

6,val.concat()//不传值为复制数组，传的话复制数组并且新数组末尾添加传的值

7，val.slice()//传位置截取数组返回新数组，一个参数就从数字位置截取到末尾，两个参数截取起始位置（结束位置前一项）传一个或两个值。如果是负数，侧以数组长度相加后返回的位置算，若开始位置小于结束位置，则返回空数组。

8，val.splice()
val.splice(0,2)--从第一位开始删除两项
val.splice(2,0,'red','yellow')--从第2位开始插入两项，删除0项
val.splice(2,1,'red','yellow')--先删除数组第二项一个，再从第2位开始插入两项，删除0项

9，位置方法
indexOf()--从数组投开始查找匀速返回元素位置，没找到返回-1.
lastIndexOf()从反方向开始查找。

10，迭代方法
every()
var numbers=number.every(function(item,index,array){
	return item>2 //所有条件满足返回true
})

some()
var numbers=number.every(function(item,index,array){
	return item>2 //有条件满足就返回true
})

filter()
var numbers=number.filter(function(item,index,array){
	return item>2 //返回符合条件的数组项组成的数组
})

forEach()
number.forEach(function(item,index,array){
	//执行操作,无返回值
})

map()
var numbers=number.map(function(item,index,array){
	return item*2 //返回执行操作后的新数组
})

2018/7/20
1,数组归并方法 reduce()/reduceRight()--es5新增加属性
reduceRight从右边开始,reduce从左边开始,用法结果一样.
var number=[1,2,3,4]
var values=number.reduce(function(prev,cur,index,array){
    return prev+cur
})//10 求和 第一次迭代prev是number[0],cur=number[1],之后prev为上次操作返回的值