StudyText

2018/03/07
1，js中forEach
forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。

2，js值类型
string，number，boolean，null，undefined，object，symbol（ES6新增类型）。
Typeof 数据：返回数据类型6个，null类型也返回object。无返回值function类型会返回function。

3，知识点：类型转换。

2018/03/08
1，js中的this:指向调用他的对象
function foo(){console.log()this.bar;}
var bar=‘global’;//定义全局变量，属于window
var obj1={//定义对象里面包含foo方法
    bar:’obj1’,
    foo:foo
}
var obj2={bar:’obj2’}//定义对象不包含foo方法

foo()//global 函数直接调用this指向window
obj1.foo();//obj1 对象调用指向调用的对象
foo.call(obj2);//obj2 改变this指向，apply与之类似
new foo();//undefined 重新new的对象中不包含bar变量，this指向new的对象

2，js中eval（）；//接受字符串作为参数传入。参数必需。要计算的字符串，其中含有要计算的 JavaScript 表达式或要执行的语句。

3，js中with 语句用于设置代码在特定对象中的作用域。


4，函数声明与函数表达式的区分：如果function是语句中第一个出现的就为函数声明，否则为函数表达式。
5，函数表达式是可以匿名的，但是函数声明不能省略名称。
6，var a=2;
     (function IIFE(global){
	var a=3;
	console.log(a);//3
	console.log(global.a);//2
     })(window)
函数立即调用，且传入参数为window，然后重命名为global进行调用。这是一种函数表达式的调用。
7，js中变量先声明，后赋值。存在声明提升。
函数声明会被提升，但是函数表达式不会提升。即函数表达式不可再声明前些调用，函数声明可以。
函数声明和变量声明都会被提升，但是函数声明hi被先提升，然后是变量。
2018/03/09
1,闭包
		for (var i = 0; i <= 5; i++) {
            (function() {
                setTimeout(() => {
                    console.log("第一个" + i);
                }, i * 1000);
            })()//输出6个6
        }
        for (var i = 0; i <= 5; i++) {
            setTimeout(() => {
                console.log("第二个" + i);
            }, i * 1000);//输出6个6
        }
        for (var i = 0; i <= 5; i++) {
            (function() {
                var j = i;
                setTimeout(() => {
                    console.log("第三个" + j);
                }, j * 1000);
            })()//输出0-5
        }

		for (var i = 0; i <= 5; i++) {
            let j = i;//var j=I—输出6个5
            setTimeout(function() {
                console.log("第四个" + j);
            }, j * 1000)//0-5
        }        for (var i = 0; i <= 5; i++) {
            (function(j) {
                setTimeout(function() {
                    console.log(j);
                }, j * 1000)
            })(i)//0-5
        }

2，this是运行时绑定，不是编写时帮定。他依赖函数上下文关系。this绑定和函数声明
的位置无关，反而和函数被调用有关。
var bar=new foo（）；//this只想new的对象
全局的话指向global，apply、call、bind的话指向绑定的调用对象。
2018/03/12
1，对象来自于两种形式：字面形式、构造形式。
内建对象：String、Number、Boolean、Object、Function、Array、Date、RegExp、Error。
2，对象访问方式：属性访问、键访问。对象中属性名总是字符串，如果使用字符串以外的类型会自动转换为字符串。
var myObject={a:2};
myObject.a;//2
myObject[“a”];//2
3，通过键动态访问，动态创建字符串键。
var idx=“a”；
var hello=“hello”;
var myObject={a:2}；
myObject[“strMsg”]=“sdjfhjfhdj”;  计算性属性名
myObject[hello+“strMsg”]=“21345”;
console.log(myObject[index]);//2
console.log(myObject[“strMsg”]);//sdjfhjfhdj
console.log(myObject[“hellostrMsg”]);//21345  计算性属性名

4,JSON.stringify();//对象转换为json对象
 JSON.parse();//json数据转换为对象

2018/03/13
1，js中，变量没有类型，值才有类型。
2，typeof操作符总是返回字符串：”number”,”string”,”object”,”function”,”boolean”,”symbol”,”undefined”.
3，js数组array是被数字索引的，可以在它们上面添加键属性添加值，但是不会记入数组长度，数组可访问。
4，var a=[]; a[“13”]=42;//a.length:14
5，indexOf();//得出索引的位置
6，concat();//数组和string拼接。原有数组和string不变。
7，string上没有一个方法是可以原地修改它的内容的，而是创建并返回一个新的string。//string不可变性
8，split()//字符串转换为数组      join()将数组转换为字符串
9，null是关键字不是标识符，undefined是标识符不是关键字。
10，js中基本数据类型是通过值拷贝(null,undefined,string,number,boolean,symbol):var a=2;var b=a;b++;b—3 a--2。
     复合值object和function总是在赋值或传递时创建一个引用的拷贝。var c=[1,2,3];var d=c;d.push(4);c==d==[1,2,3,4]。
11，function(x){
	x.push(4);
	x;//[1,2,3,4]
	
	x=[4,5,6];//重新赋值，对原来的引用a无影响
	x.push(7);//x:[4,5,6,7]
     }
     var a=[1,2,3];
     foo(a); a的值依然为[1,2,3,4]而不是[4,5,6,7]

要改变a，不能新建array而要修改现存的array值
function foo(x){
  x.push(4);//x,a—[1,2,3,4]
  x.length=0;
  x.push(4,5,6,7);//x,a—[4,5,6,7]
}
  var a=[1,2,3];
  foo(a); a的值依然为[4,5,6,7]而不是[1,2,3,4]
12，toString()返回对象类型—[object type]
Object.prototype.toString.call([1,2,3]);//“[object Array]”
13，String.prototype.XYZ会被缩写为String#XYZ。
String#indexOf(…)//在一个字符串中找出子字符串的位置
String#charAt(…)//访问一个字符串中某个位置的字符
String#substr(…)/substring(…)/slice(…)//将字符串的一部分抽取为一个新字符串
String#toUpperCase()/toLowerCase()//创建一个转换大小写的新字符串
String#trim//创建一个截去开头或结尾空格的新字符串。


2018/03/23
1，html hash
2，scrollIntoView
3，document.documentElement.scrollTop || document.body.scrollTop 页面滚动条离顶部距离
4，sticky footer

2018/03/29
1，table-layout:fixed;以及table布局；
学习到7-10

2018/06/11
1.检测类型：typeof ‘检测的数据’--（string.number.boolean.undefined.object(包括null)）;
2,‘检测的对象’ instanceof Object/Array/RegExp 返回true或false，基本数据类型检测永远返回false--因为基本数据类型不是对象.--es3加属性

2018/07/19
1,Array.isArray(value)--es5新增加属性

2，所有对象都具有toLocalString()/toString()/valueOf()方法。
value.toString()--操作数组返回数组中值为以逗号分隔的字符串
value.valueOf()--操作数组返回的还是数组
join()--拼接数组为字符串 括号内不传值或者unedefined，默认为逗号拼接
toLocalString()/toString()/valueOf()/join()--数组中某项为null、undefined，返回结果中用空字符串表示。

3，数组的栈方法--push、pop  --栈后进先出
A,push向数组末尾添加元素；返回新的数组
B,pop移除数组最后一项，返回移除项的值。

4，数组队列方法--队列先进先出 unshift、shift
shift()返回移除项值，移除的为数组第一项。
unshift()在数组前面添加元素。

5，数组重排序方法
A.reverse()--由大到小排序，反转数组排序
B,SORT()--默认情况下升序 [0,1,10,5,15]--返回[0,1,10,15,5] 以toString比较后返回值
手动添加比较函数完善
Var item=[0,1,10,5,15]
funtion compare(val1,val2){
	return val2-val1;
}
item.sort(compare);--ok [0,1,5,10,15]

6,val.concat()//不传值为复制数组，传的话复制数组并且新数组末尾添加传的值

7，val.slice()//传位置截取数组返回新数组，一个参数就从数字位置截取到末尾，两个参数截取起始位置（结束位置前一项）传一个或两个值。如果是负数，侧以数组长度相加后返回的位置算，若开始位置小于结束位置，则返回空数组。

8，val.splice()
val.splice(0,2)--从第一位开始删除两项
val.splice(2,0,'red','yellow')--从第2位开始插入两项，删除0项
val.splice(2,1,'red','yellow')--先删除数组第二项一个，再从第2位开始插入两项，删除0项

9，位置方法
indexOf()--从数组投开始查找匀速返回元素位置，没找到返回-1.
lastIndexOf()从反方向开始查找。

10，迭代方法
every()
var numbers=number.every(function(item,index,array){
	return item>2 //所有条件满足返回true
})

some()
var numbers=number.every(function(item,index,array){
	return item>2 //有条件满足就返回true
})

filter()
var numbers=number.filter(function(item,index,array){
	return item>2 //返回符合条件的数组项组成的数组
})

forEach()
number.forEach(function(item,index,array){
	//执行操作,无返回值
})

map()
var numbers=number.map(function(item,index,array){
	return item*2 //返回执行操作后的新数组
})

2018/7/20
1,数组归并方法 reduce()/reduceRight()--es5新增加属性
reduceRight从右边开始,reduce从左边开始,用法结果一样.
var number=[1,2,3,4]
var values=number.reduce(function(prev,cur,index,array){
    return prev+cur
})//10 求和 第一次迭代prev是number[0],cur=number[1],之后prev为上次操作返回的值

2,Date--UTC,1970-01-01-00:00,毫秒数
var now = new Date();

Date.parse(日期)--返回日期毫秒数
Date.parse参数:月/日/年(7/16/2017);January 12,2014;
英文星期 英文月 日 年 时:分:秒 时区;2004-05-25T00:00:00.

Date.UTC(日期)--返回日期毫秒数 参数:年,月(0开始),日,时,份,秒,毫秒数(年,月必须).

var now=Date.now()//当前时间毫秒数 es5新增加属性 不支持的浏览器用 var now =+new Date()--返回毫秒数
now.getFullYear--年(2018)  now.getMonth--月(0表示一月)
getDate--日(1到31) getHours--时(超过23天加一) getMinutes--份(0-59) getSeconds--秒(0-59)

var mow=new Date()
var date=mow.getFullYear()+'/'+mow.getMonth()+'/'+mow.getDate()+' '+mow.getHours()+':'+mow.getMinutes()+':'+mow.getSeconds()

3,RegExp正则
必须转义的元字符 ([{\%^|)?*+.}] 使用\转义字符前
var par1=/\.at/ ;--字面量表达式
var par=new RegExp("[qs]sd","i");--构造函数
在字符串中元字符要双重转义 /\.at/=="\\.at"

正则方法:匹配规则.exec(字符串))--返回匹配项,全局返回多个,非全局返回第一个;
匹配规则.test(字符串))--true/false

2018/07/23
1,Function--函数名实际也是一个指向函数对象的指针,不会与某个函数绑定.函数无重载.

2,函数定义:
    a,函数声明:function test(){} //解析器函数声明提升,即使函数声明在调用后也可正常运行.
    b,函数表达式:var test=function(){};//末尾有分号;无函数名称,通过test变量引用函数.
    c,Function构造函数:var test=new Function("num1","num2","return num1+num2")//接受任意数量参数,最后一个参数永远被看成函数体
eg:
function test(num1,num2){
    return num1+num2;
}
test(10,10);//20
var haha=test;//使用不带圆括号的函数名是访问函数指针,非调用函数.
haha(5,5);//10

function test(name){	
	console.log(arguments)
    return function(num1,num2){
		console.log(arguments)
        var val1=num1[name];
        var val2=num2[name];
		if(val1<val2){
			return 1
		}else if(val1>val2){
			return -1
		}else{return 0;}
    }	
}
data.sort(test('age'));

3,函数内部属性
a,arguments--类数组对象,包含着传入函数中的所有参数.其callee属性是指针,指向拥有这个arguments对象的函数
function factorial(num){//阶乘 
	if(num<=1){
		return 1
	}else{
		return num*arguments.callee(num-1);
	}
}
b,this引用的是函数执行的对象.

4,每个函数都包含两个属性:lenght--希望传递的参数个数,prototype--保存所有的实例方法,不可枚举,for-in无法发现.

5,每个函数都包含两个非继承而来的方法:apply(),call().用途--在特定的作用域中调用函数,等于设置函数体内this对象的值.
a,apply--参数1函数作用域,参数二参数数组(arguments或Array实例)
function sum (num1,num2){
	return num1+num2
}
function callSum1(num1,num2){
	return sum.apply(this,arguments);//或return sum.apply(this,[num1,num2]);
}
b,call的区别在于接受参数必须逐个列出来.

6,es5新增加属性--bind()
var o={color:'blue'}
window.color='red'
function sayColor(){
	console.log(this.color);
}
var bindSay=sayColor.bind(o)
bindSay()//必须调用新函数,apply和call在原函数基础直接调用.

2018/07/24
1.String类型:
concat()--拼接成新字符串:var newVal=oldVal.concat(str1,str2,str3...)//直接+一样的作用
slice()/substr()/substring():接受一个或两个参数,第一个参数代表截取开始位置(从0开始),
slice()/substring()第二个参数指截取结束位置(获取前一项),substr()第二个参数是截取长度.第二个参数没有就截取到元素末尾.
slice()/substr()第一个参数为负数长度与之相加,substr()第二个参数为负转换为0,slice()与第一个参数处理相同.
substring()将负数转换为0,两个参数谁大以谁为第二个参数.

2018/07/25
1,获取字符串位置
indexOf(要匹配的字符,[index])/lastIndexOf(要匹配的字符,[index]):搜索字符串出现位置(初始0),找到范hi索引位置,没找到返回-1,index不填默认为0.

2,去掉字符串空格并返回副本.trim():去掉字符串前后空格,trimLeft()/trimRight()分别删除左右空格.

3,大小写转换.toLowerCase()/toUpperCase()/toLocaleLowerCase()/toLocaleUpperCase().

4,字符串的模式匹配:match(正则表达式/RegExp对象)--返回数组包含匹配项;search(正则表达式/RegExp对象)--始终从头匹配,返回第一个匹配项索引,没有返回-1.
replace(正则表达式/RegExp对象/字符串,替换为的字符串/函数).

5,localeCompare():比较两个字符串,大于返回正数,小于返回负数,等于返回0.
var str1='yello',str2='blue';str1.localeCompare(str2)//正数

6,Math:var num=Math.floor(Math.random()*10+1)//1到10之间的随机整数
Math.floor()//向下取整 ; Math.ceil()//向上取整 ; Math.round()//四舍五入.
var val=[1,46,7,82,17,83,7,8,21,32]
var max=Math.max.apply(Math,val)//取最大值

7,对象:属性和方法
a,属性含有特征值,ECMAScript中有两中属性:数据属性和访问器属性.
b,数据属性包含一个数据值得位置.在这个位置可以读值和写入值.其包含四儿猫叔行为的特性:
[[Conficurable]]:能否delete删除属性从而定义新属性,能否修改属性特性,能否把属性修改为访问器属性.默认true.
[[Enumerable]]:能否通过for-in循环返回属性.默认true.
[[Writable]]:能否修改属性的值.默认true.
[[Value]]:包含属性的数据值.默认undefined.
Object.defineProperty(属性所在对象,属性名,描述符对象(conficurable/enumerable/writable/value)):修改属性的默认特性.
//如果定义了conficurable为false,则出writable外其他属性不可修改,writable不可设置为true.
var per={}
Object.defineProperty(per,'name',{//如果定义了未指定的属性则conficurable/enumerable/writable未定义都为false,定义了的话无限制
    writable:false,
    value:'emma'
});
per.name;//emma
c,访问器属性:必须使用Object.defineProperty()定义.
[[Conficurable]]:能否delete删除属性从而定义新属性,能否修改属性特性,能否把属性修改为访问器属性.默认true.
[[Enumerable]]:能否通过for-in循环返回属性.默认true.
[[Get]]:读属性,默认undefined;[[Set]]]:写属性,,默认undefined.
d,Object.defineProperty(属性所在对象,{属性名:{数据属性/访问器属性}...})//批量定义多个.es5新增加属性.
e,Object.getOwnPropertyDescriptor(属性所在对象,'属性名字')//返回属性特征对象.

8,工厂模式创建对象:可以创建多个对象,但是没办法值到一个对象的类型.
function creatObj(name,age,job){
    var o=new Object();
    o.name=name;
    o.age=age;
    o.job=job;
    o.sayJob=function(){
        alert(this.job)
    }
    return o;
}
var per1=creatObj('emma',12,'hah1');var per2=creatObj('emma123123',22,'hah1122').

9,构造函数模式
function Per(name,age,job){//构造函数名大写,无显示创建对象,无return语句.含有constructor属性
    this.name=name;
    this.age=age;
    this.job=job;
}
var per1=new Per('emma',12,'hah1');var per2=new Per('emma12',1212,'hah2132131');//含有constructor属性,等于Per.

10,原型模式:prototype
isPrototypeOf(),hasOwnPrototy()--只能用于对象的实例.
for...in...:不可枚举属性不返回在循环中.//Object.keys();
实例中的指针指向原型,不是指向构造函数.

11,原型链:原型链作为继承的主要方法,其基本思想是利用原型让一个原型继承另一个引用类型的属性和方法.

2018/07/25
1,instanceof:判断一个实例是否属于某种类型.

函数表达式
1,定义函数方式:函数声明,函数表达式.
function test(){//函数体}//函数声明;--函数声明提升.
var test=function(){//函数体}//函数表达式.

2,闭包
function creat(){
	var res=new Array();
	for(var i=0;i<10;i++){
		res[i]=function(num){
			console.log(i,num);//10 5
			return function(){
				return num;
			}
		}
	}
	return res;
}
creat()[0](5);//5  console.log(i,num);//10 5

function creat(){
	var res=new Array();
	for(var i=0;i<10;i++){
		res[i]=function(num){
			console.log('step1',i,num);
			return function(){
				console.log('step2',i,num);
				return num;
			};
		}(i);//^__^
	}
	return res;
}

function creat(){
	var res=new Array();
	for(var i=0;i<10;i++){
		res[i]=function(num){
			return num;
		}(i);//函数参数是按值传递的,所以将i的当前值传递给num.
	}
	return res;
}
creat()//[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

function creat(){
	var res=new Array();
	for(var i=0;i<10;i++){
		res[i]=function(){
			return i;
		}();
	}
	return res;
}
creat()//[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


function creat(){
	var res=new Array();
	for(var i=0;i<10;i++){
		res[i]=function(){
			return i;
		};
	}
	return res;
}
creat()[0]();//10

2,匿名函数的执行环境具有全局性,因此this对象通常指向window.

var name='one';
var obj={
	name:'two',
	getName:function(){
		return function(){//匿名函数只能找到其活动对象为止,找不到使用全局.
			return this.name
		}
	}
}
obj.getName()()//one
var obj={
	name:'two',
	getName:function(){
		return this.name
	}
}
obj.getName()//two

3,模仿块级作用域.
(function(){//块级作用域})()//用作块级作用域的匿名函数
function(){//块级作用域}()--报错,因为js将function当做函数声明的开始,函数后面不能跟圆括号,函数表达式后面可以,加括号给函数声明变为函数表达式.



